# Windows Server 攻防測試實務
## 環境建置
## Kali Linux攻擊
## Windows 防禦
- 偵測連線 ==> netstat 指令
- 檢視執行的process 及process ID(PID) ==> netstat -anob
  - tasklist |  findstr notepad(10.0.2.15) 
- 檢視惡意程式位置 `C:\Windows\TEMP\XXXX.jar`
- 刪除惡意程式的連線 ==> Taskkill \PID  XXXX /F

# 更多作業
- 執行wireshark側錄封包 ==> 分析封包
- 將惡意程式丟到GEMINI | Chatgpt | VirusTotal | Any.run去分析 

## Metasploit
- 攻擊程式 ==> 使用ruby
- /use/bin/msfconsole
- /use/share/metasploit-framework
- /use/share/metasploit-framework/modules ==> 說明這六大模組
- 

## Powershell ==> parrot
- powershell用處

```powershell
# 定義 Registry 的路徑 (包含 64位元, 32位元 和 當前使用者路徑)
$RegPaths = @(
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
    "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall",
    "HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
)

# 建立一個空的陣列來儲存結果
$InstalledSoftware = @()

# 遍歷每一個路徑
foreach ($Path in $RegPaths) {
    # 檢查路徑是否存在以避免錯誤
    if (Test-Path $Path) {
        # 獲取該路徑下的所有子項目，並讀取屬性
        $Keys = Get-ChildItem -Path $Path | Get-ItemProperty

        foreach ($Key in $Keys) {
            # 過濾掉沒有 DisplayName (顯示名稱) 的項目 (通常是系統組件或更新檔)
            if ($null -ne $Key.DisplayName) {
                
                # 建立自定義物件整理資料
                $SoftwareInfo = [PSCustomObject]@{
                    Name      = $Key.DisplayName
                    Version   = $Key.DisplayVersion
                    Publisher = $Key.Publisher
                    Date      = $Key.InstallDate
                    Source    = $Path # 標記來源路徑方便除錯
                }
                $InstalledSoftware += $SoftwareInfo
            }
        }
    }
}

# 顯示結果：去除重複名稱，並按名稱排序
# 使用 Out-GridView 可以產生一個可搜尋、排序的視窗
$InstalledSoftware | Sort-Object Name | Select-Object * -Unique | Out-GridView -Title "已安裝軟體清單 (Registry 解析)"

# 若只想在終端機顯示，請使用下面這一行取代上面那一行：
# $InstalledSoftware | Sort-Object Name | Select-Object Name, Version, Publisher -Unique | Format-Table -AutoSize
```
